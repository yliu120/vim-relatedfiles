''' This file serves as a vim plugin for opening header/source/test files
    for C/C++ developers. We will probably support Python source/test as well
    in the future.
    Usage:
'''
import os
import re
import vim

# TODO(yliu120): Customize unit test file detection
# For unittest files, we currently only support Google/Facebook's style.
# Later on, this feature should be customized by the user.
TEST_PATTERN = re.compile("[a-z_]+_test$|[a-zA-Z]+Test$")
FILE_EXT = {'build': frozenset(['Makefile', 'makefile', 'BUILD',
                                'CMakeLists.txt']),
            'hdr': frozenset(['h', 'hpp']),
            'src': frozenset(['c', 'cc', 'cpp']),
            'test': frozenset(['c', 'cc', 'cpp'])}


def build_file_list_with_ext(option, status, file_name):
    '''Build a list of files that with different possible extensions '''
    potential_names = []
    if option == 'build':
        potential_names.extend(list(FILE_EXT[option]))
        return potential_names

    if option == 'test':
        potential_names.append(file_name + "_test")
        potential_names.append(file_name + "Test")
    elif status == 'test':
        potential_names.append(re.split("(_test|Test)$", file_name)[0])
    else:
        potential_names.append(file_name)

    file_list = []
    for ext in FILE_EXT[option]:
        file_list.extend([name + '.' + ext for name in potential_names])
    return file_list


def display_related_files(file_lists):
    '''Display a list of files in vim message console '''
    msg = "We found multiple related files: \n"

    index = 1
    for f_name in file_lists:
        # use string concat as += since the file_lists should be
        # relatively small, there are no performance considerations here.
        msg += "%d) %s\n" % (index, f_name)
        index += 1

    msg += "Your choice: "
    return msg


def get_user_choice(message):
    '''Get user's choice if we found multiple files '''
    try:
        vim.command('call inputsave()')
        vim.command("let user_input = input('" + message + "')")
        vim.command('call inputrestore()')
        choice = int(vim.eval('user_input'))

        if choice < 0:
            raise ValueError

        vim.command('unlet user_input')
    except (vim.error, ValueError, KeyboardInterrupt):
        return -1

    return choice - 1


def related_files(option, status, path, name):
    '''Find all source files in path that starts with name'''
    files = []

    # Construct a regex pattern for matching
    pattern = ""
    if option != 'build':
        if status == 'test':
            pattern = re.split("(_test|Test)$", name)[0]
        elif option == 'test':
            pattern = name + "(_test|Test)"
        pattern += '\\.'

    pattern = pattern + '(' + '|'.join(FILE_EXT[option]) + ')$'
    file_pattern = re.compile(pattern)
    for fname in os.listdir(path):
        if file_pattern.match(fname):
            files.append(fname)

    return files


def parse_buffer_name(name):
    '''Parse the path of the buffer into a tuple of filetype and module name'''

    module_file = name.split('/').pop()
    path = name[:name.rfind(module_file)]
    module = module_file.split('.')
    if len(module) > 2:
        raise ValueError

    module_ext = module[1] if len(module) == 2 else None
    return (module_ext, path, module[0])


def open_related_file(filename):
    '''Run Bazel command generated by the above function '''
    try:
        # Clear the screen before running bazel.
        vim.command("e %s" % filename)
    except vim.error:
        print "VIM Failed when opening file %s." % filename
        return -1

    return 0


def Run(option):
    '''The entry method to the whole plugin '''
    if option not in FILE_EXT:
        return -1

    buf_name = vim.current.buffer.name
    try:
        file_type, path, mod_name = parse_buffer_name(buf_name)
    except ValueError:
        print "Your file name doesn't follow the naming standard."
        return -1

    # the file status (build/src/hdr/test) of current buffer
    status = None
    if TEST_PATTERN.match(mod_name):
        if file_type in FILE_EXT['test']:
            status = 'test'
        else:
            print "Invalid file naming for unit tests."
            return -1
    else:
        for ftype in FILE_EXT:
            if file_type in FILE_EXT[ftype]:
                status = ftype

    # We don't do anything if we are already in that file.
    if status is None:
        print "Your file type is not recognized."
        return -1
    if status == option:
        return 0

    related_file_names = related_files(option, status, path, mod_name)
    related_file_name = None

    if len(related_file_names) == 1:
        related_file_name = related_file_names[0]
    else:
        if len(related_file_names) == 0:
            # User may want to create a new file with certain option.
            related_file_names = build_file_list_with_ext(
                option, status, mod_name)
        choice = get_user_choice(display_related_files(related_file_names))

        if choice < 0 or choice > len(related_file_names) - 1:
            vim.command("silent !clear")
            print "Invalid Choice %d (not in [%d, %d])" \
                % (choice, 1, len(related_file_names))
            return -1

        related_file_name = related_file_names[choice]

    return open_related_file(related_file_name)
